# main.py
# This script is the main entry point for the FastAPI application.
# It defines the API endpoints, handles request validation, and orchestrates
# the calls to the database and AI services.

from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from datetime import datetime
import uuid
from typing import Optional

# --- Local Imports ---
from database import get_db, engine
from models import Base
from schemas import (
    ChatRequest, ChatResponse, ConversationHistory,
    ErrorResponse, HealthResponse
)
from db_operations import (
    create_conversation, get_conversation,
    update_conversation,
    list_conversations
)
from ai_service import get_ai_decision

# Create database tables upon application startup
# This ensures that the necessary tables exist before the app starts accepting requests.
Base.metadata.create_all(bind=engine)

# Initialize FastAPI app with metadata for documentation
app = FastAPI(
    title="AI Customer Support Bot API",
    description="Backend API for AI-powered customer support with session management",
    version="1.0.0"
)

# Configure CORS (Cross-Origin Resource Sharing) middleware
# This allows the frontend (running on a different domain) to communicate with this API.
# For production, it's recommended to restrict allow_origins to the specific frontend URL.
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allows all origins
    allow_credentials=True,
    allow_methods=["*"],  # Allows all methods (GET, POST, etc.)
    allow_headers=["*"],  # Allows all headers
)

@app.get("/", tags=["Root"])
async def root():
    """Root endpoint providing basic API information and a link to the docs."""
    return {
        "message": "Welcome to the AI Customer Support Bot API",
        "version": "1.0.0",
        "documentation": "/docs"  # Auto-generated by FastAPI
    }

@app.get("/health", response_model=HealthResponse, tags=["Health"])
async def health_check(db: Session = Depends(get_db)):
    """
    Performs a health check on the API and its database connection.
    Returns the operational status, useful for monitoring.
    """
    try:
        # A simple query to check if the database is responsive and accepting connections.
        from sqlalchemy import text
        db.execute(text("SELECT 1"))
        db_status = "connected"
    except Exception as e:
        db_status = f"error: {str(e)}"
    
    return HealthResponse(
        status="healthy" if db_status == "connected" else "unhealthy",
        timestamp=datetime.utcnow().isoformat(),
        database=db_status
    )

@app.post(
    "/api/chat",
    response_model=ChatResponse,
    status_code=status.HTTP_200_OK,
    tags=["Chat"],
    responses={
        200: {"description": "Successful response from the AI"},
        400: {"model": ErrorResponse, "description": "Invalid request body"},
        404: {"model": ErrorResponse, "description": "Session ID not found"},
        500: {"model": ErrorResponse, "description": "Internal server error"}
    }
)
async def chat(
    request: ChatRequest,
    db: Session = Depends(get_db)
):
    """
    Main chat endpoint for handling all customer support interactions.

    This endpoint manages the entire lifecycle of a chat message:
    - Creates a new session if `session_id` is not provided.
    - Retrieves an existing conversation if `session_id` is provided.
    - Calls the AI service to get an intelligent response.
    - Persists the full conversation history to the database.
    """
    try:
        session_id = request.session_id
        conversation = None
        
        # If a session_id is provided, try to retrieve the existing conversation.
        if session_id:
            conversation = get_conversation(db, session_id)
            if not conversation:
                # If the session_id is invalid, raise a 404 error.
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail=f"Session {session_id} not found"
                )
        else:
            # If no session_id is provided, create a new conversation.
            conversation = create_conversation(db)
        
        session_id = conversation.session_id
        history = conversation.history or []

        # Orchestrate the call to the AI service to get a decision (answer or escalate).
        ai_result = await get_ai_decision(history, request.user_message)
        new_status = "escalated" if ai_result.is_escalated else "active"

        # Prepare message objects in a structured format for database storage.
        user_message = {
            "role": "user",
            "content": request.user_message,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        assistant_message = {
            "role": "assistant",
            "content": ai_result.content,
            "timestamp": datetime.utcnow().isoformat()
        }
        
        # Update the conversation history in the database with the new messages.
        update_conversation(db, session_id, user_message)
        update_conversation(db, session_id, assistant_message, status=new_status)
        
        # Return the structured response to the client.
        return ChatResponse(
            session_id=session_id,
            response=ai_result.content,
            is_escalated=ai_result.is_escalated,
            status=new_status,
            summary=ai_result.summary
        )
        
    except HTTPException:
        # Re-raise HTTP exceptions to let FastAPI handle them correctly.
        raise
    except Exception as e:
        # Catch any other unexpected errors and return a generic 500 response.
        print(f"An unexpected error occurred in /api/chat: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An internal error occurred: {str(e)}"
        )

@app.get(
    "/api/conversations/{session_id}",
    response_model=ConversationHistory,
    tags=["Conversations"],
    responses={
        200: {"description": "Conversation history found"},
        404: {"model": ErrorResponse, "description": "Conversation not found"}
    }
)
async def get_conversation_details(
    session_id: uuid.UUID,
    db: Session = Depends(get_db)
):
    """
    Retrieves the full message history of a specific conversation by its session_id.
    Useful for debugging or allowing users to view past chats.
    """
    conversation = get_conversation(db, session_id)
    
    if not conversation:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Conversation with session_id {session_id} not found"
        )
    
    return ConversationHistory(
        session_id=conversation.session_id,
        created_at=conversation.created_at,
        updated_at=conversation.updated_at,
        status=conversation.status,
        history=conversation.history or [],
        message_count=len(conversation.history or [])
    )

@app.get(
    "/api/conversations",
    response_model=list[ConversationHistory],
    tags=["Conversations"]
)
async def list_all_conversations(
    limit: int = 50,
    offset: int = 0,
    status: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """
    Lists all conversations with pagination support. Can be filtered by status
    (e.g., 'active', 'escalated'). Useful for an admin dashboard.
    """
    conversations = list_conversations(db, limit=limit, offset=offset, status=status)
    
    return [
        ConversationHistory(
            session_id=conv.session_id,
            created_at=conv.created_at,
            updated_at=conv.updated_at,
            status=conv.status,
            history=conv.history or [],
            message_count=len(conv.history or [])
        )
        for conv in conversations
    ]

# This block allows running the app directly with `python main.py` for local development.
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)

